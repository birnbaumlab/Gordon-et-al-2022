#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jun 18 11:23:06 2021

@author: khloegordon
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Aug 28 15:48:24 2019

This code is designed to cluster barcode counts generated by Illumina sequencing data
by comparing levenshtein distance between barcodes. n_edits is the maximum allowable 
edit distance that will result in two barcodes being clustered together.

@author: khloegordon
"""

import os
import pandas as pd
import numpy as np
import xlsxwriter
import editdistance
import distance

''' Fill in selection names and identify number of rounds of selections, 
matching Excel file output from DomainSeq (dataset_000X.xlsx)'''


settings = {'selection': ['CD69+PD','CD69+PD-1-'], 
            'round': [[0,1,2,3],[0,1]], 
            'n_edits': 2}

                        
def filternestedBCs(path,file,sheet,criteria):
    
    os.chdir(path)
    
    df1 = pd.read_excel(file, sheet_name = sheet)
    
    #print(df1)
    
    writer = pd.ExcelWriter('dataset_unnested.xlsx', engine = 'xlsxwriter')
    #workbook = xlsxwriter.Workbook('dataset_unnested.xlsx')
    
    for val,n in zip(criteria['selection'],criteria['round']):
        
        for rnd in n:
            
            # Sort multiplexed data by selection strategy and round of selection
            data = df1[(df1['Dataset'] == val) & (df1['Round'].values == rnd)].sort_values(by = ['Count'], ascending = False)
            bcs = data['BC'].astype(str).values.tolist()
            # initialize true/false matrix where true indicates that a barcode has been matched
            matched = [[bc,False] for bc in bcs] 
            print('Filtering barcodes from {} selection round {}'.format(val,rnd))
            
            for i,bc1 in enumerate(bcs): 
                for j,item in enumerate(matched[i+1:]): 
                # bc1 is the reference barcode (higher frequency)
                # item[0] is the barcode that is compared to the reference barcode (lower frequency)
                    
                    #print('Comparing {} to {}'.format(item[0],bc1))
                    
                    if not item[1]: # if not yet matched
                        # compare Levenshtein distance
                        if editdistance.eval(bc1,item[0]) <= criteria['n_edits']:
                            
                            matched[i+j+1][1] = True
                            # add matched barcode to reference barcode count
                            data.loc[data.index[i],'Count'] += data.loc[data.index[i+j+1],'Count']
                            print('{} matched to {}!'.format(item[0],bc1))
                            
            matches = [item[1] for item in matched]
            not_matched = [not item for item in matches] # filter for unmatched barcodes
            n_matches = sum(matches)
            print('{} match(es) found for {} selection round {} data!'.format(n_matches,val,rnd))
            # remove entries that were matched to higher frequency entries
            data = data[not_matched]
            
            data.to_excel(writer, sheet_name = '{} R{}'.format(val,rnd))
                
    writer.save()
    writer.close()
    
    print('Nested barcodes filtered! Dataset exported.')
    

filternestedBCs(path = '/Users/khloegordon/Dropbox (MIT)/Code/DomainSeq/datasets',
              file = 'dataset_0002.xlsx',
              sheet = 'DATA',
              criteria = settings)

print('\nfilternestedBCs finished!')
